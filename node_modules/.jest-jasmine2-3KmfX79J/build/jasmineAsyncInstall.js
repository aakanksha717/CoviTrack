'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = jasmineAsyncInstall;

var _co = _interopRequireDefault(require('co'));

var _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));

var _throat = _interopRequireDefault(require('throat'));

var _isError3 = _interopRequireDefault(require('./isError'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;
var Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

function isPromise(obj) {
  return obj && typeof obj.then === 'function';
}

function promisifyLifeCycleFunction(originalFn, env) {
  return function(fn, timeout) {
    if (!fn) {
      return originalFn.call(env);
    }

    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;

    if (hasDoneCallback) {
      // Jasmine will handle it
      return originalFn.call(env, fn, timeout);
    }

    const extraError = new Error(); // Without this line v8 stores references to all closures
    // in the stack in the Error object. This line stringifies the stack
    // property to allow garbage-collecting objects on the stack
    // https://crbug.com/v8/7142

    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they
    // didn't return a promise.

    const async